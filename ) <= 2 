[1mdiff --git a/cmd/run.go b/cmd/run.go[m
[1mindex 3940e1c..8a2ce27 100644[m
[1m--- a/cmd/run.go[m
[1m+++ b/cmd/run.go[m
[36m@@ -1,7 +1,7 @@[m
 package cmd[m
 [m
 import ([m
[31m-	"fmt"[m
[32m+[m	[32m"errors"[m
 	"os"[m
 [m
 	"github.com/alingse/go-linter-runner/runner"[m
[36m@@ -17,21 +17,24 @@[m [mvar runCmd = &cobra.Command{[m
 		yamlConfig := string(yamlData)[m
 		jsonConfig := *jsonConfigPtr[m
 		if yamlConfig == "" && jsonConfig == "" {[m
[31m-			return fmt.Errorf("one of the options -y and -j must be set.")[m
[32m+[m			[32mreturn errors.New("one of the options -y and -j must be set.")[m
 		}[m
 [m
 		repo := *repoURLPtr[m
 		if repo == "" {[m
[31m-			return fmt.Errorf("the -r/--repo muest be set.")[m
[32m+[m			[32mreturn errors.New("the -r/--repo muest be set.")[m
 		}[m
 		runner.Run(repo, jsonConfig, yamlConfig)[m
[32m+[m
 		return nil[m
 	},[m
 }[m
 [m
[31m-var jsonConfigPtr *string[m
[31m-var yamlConfigPtr *string[m
[31m-var repoURLPtr *string[m
[32m+[m[32mvar ([m
[32m+[m	[32mjsonConfigPtr *string[m
[32m+[m	[32myamlConfigPtr *string[m
[32m+[m	[32mrepoURLPtr    *string[m
[32m+[m[32m)[m
 [m
 func init() {[m
 	rootCmd.AddCommand(runCmd)[m
[1mdiff --git a/cmd/submit.go b/cmd/submit.go[m
[1mindex 7ed288d..446018e 100644[m
[1m--- a/cmd/submit.go[m
[1m+++ b/cmd/submit.go[m
[36m@@ -1,7 +1,7 @@[m
 package cmd[m
 [m
 import ([m
[31m-	"fmt"[m
[32m+[m	[32m"errors"[m
 	"log"[m
 [m
 	"github.com/alingse/go-linter-runner/runner"[m
[36m@@ -15,26 +15,29 @@[m [mvar submitCmd = &cobra.Command{[m
 	RunE: func(cmd *cobra.Command, args []string) error {[m
 		sourceFile := *sourceFilePtr[m
 		if sourceFile == "" {[m
[31m-			return fmt.Errorf("--source is required")[m
[32m+[m			[32mreturn errors.New("--source is required")[m
 		}[m
 		repoCount := *repoCountPtr[m
 		if repoCount <= 0 {[m
[31m-			return fmt.Errorf("--count muest greater than zero")[m
[32m+[m			[32mreturn errors.New("--count muest greater than zero")[m
 		}[m
 		workflow := *workflowPtr[m
 		if workflow == "" {[m
[31m-			return fmt.Errorf("--workflow is required")[m
[32m+[m			[32mreturn errors.New("--workflow is required")[m
 		}[m
 		log.Printf("submit task with source:%s repo count: %d and workflow %s\n",[m
 			sourceFile, repoCount, workflow)[m
 		runner.Submit(sourceFile, repoCount, workflow)[m
[32m+[m
 		return nil[m
 	},[m
 }[m
 [m
[31m-var sourceFilePtr *string[m
[31m-var repoCountPtr *int64[m
[31m-var workflowPtr *string[m
[32m+[m[32mvar ([m
[32m+[m	[32msourceFilePtr *string[m
[32m+[m	[32mrepoCountPtr  *int64[m
[32m+[m	[32mworkflowPtr   *string[m
[32m+[m[32m)[m
 [m
 func init() {[m
 	rootCmd.AddCommand(submitCmd)[m
[1mdiff --git a/runner/run.go b/runner/run.go[m
[1mindex c3fa3de..f0a3dc3 100644[m
[1m--- a/runner/run.go[m
[1m+++ b/runner/run.go[m
[36m@@ -9,36 +9,44 @@[m [mimport ([m
 )[m
 [m
 func Run(repo string, jsonCfg string, yamlCfg string) {[m
[31m-	var cfg, err = run.LoadCfg(repo, jsonCfg, yamlCfg)[m
[32m+[m	[32mcfg, err := run.LoadCfg(repo, jsonCfg, yamlCfg)[m
 	if err != nil {[m
 		log.Fatal("load config failed: ", err)[m
[32m+[m
 		return[m
 	}[m
 [m
[31m-	var ctx = context.Background()[m
[31m-	var defaultTimeout = 10 * 60 * time.Second[m
[32m+[m	[32mctx := context.Background()[m
[32m+[m
[32m+[m	[32mdefaultTimeout := 10 * 60 * time.Second[m
[32m+[m
 	ctx, cancel := context.WithTimeout(ctx, cfg.GetTimeout(defaultTimeout))[m
 	defer cancel()[m
 [m
 	err = run.Prepare(ctx, cfg)[m
 	if err != nil {[m
 		log.Fatal("failed in prepare linter:", err)[m
[32m+[m
 		return[m
 	}[m
 [m
 	err = run.Build(ctx, cfg)[m
 	if err != nil {[m
 		log.Printf("build failed and exit %+v %s", err, err.Error())[m
[32m+[m
 		return[m
 	}[m
 [m
 	outputs, err := run.Run(ctx, cfg)[m
 	if err != nil {[m
 		log.Fatal("failed in run linter:", err)[m
[32m+[m
 		return[m
 	}[m
[32m+[m
 	if len(outputs) == 0 {[m
 		log.Println("no valid output after run")[m
[32m+[m
 		return[m
 	}[m
 [m
[36m@@ -49,6 +57,7 @@[m [mfunc Run(repo string, jsonCfg string, yamlCfg string) {[m
 [m
 	if len(outputs) == 0 {[m
 		log.Println("no valid output after parse and filter")[m
[32m+[m
 		return[m
 	}[m
 [m
[36m@@ -58,6 +67,7 @@[m [mfunc Run(repo string, jsonCfg string, yamlCfg string) {[m
 		err = run.CreateIssueComment(ctx, cfg, outputs)[m
 		if err != nil {[m
 			log.Fatalf("failed to CreateIssueComment err %+v \n", err)[m
[32m+[m
 			return[m
 		}[m
 	}[m
[1mdiff --git a/runner/run/config.go b/runner/run/config.go[m
[1mindex 4e5475e..fae5316 100644[m
[1m--- a/runner/run/config.go[m
[1m+++ b/runner/run/config.go[m
[36m@@ -30,21 +30,24 @@[m [mtype LinterCfg struct {[m
 	Excludes       any    `json:"excludes"        yaml:"excludes"`[m
 	IssueID        string `json:"issue_id"        yaml:"issue_id"`[m
 	Timeout        string `json:"timeout"         yaml:"timeout"`[m
[31m-	EnableTestFile bool   `json:"enable_testfile" yaml:"enable_testfile"`[m
[32m+[m	[32mEnableTestfile bool   `json:"enable_testfile" yaml:"enable_testfile"`[m
 }[m
 [m
 func LoadCfg(repo, jsonCfg, yamlCfg string) (*Config, error) {[m
 	var linterCfg LinterCfg[m
[32m+[m
 	var err error[m
 	if yamlCfg != "" {[m
 		err = yaml.Unmarshal([]byte(yamlCfg), &linterCfg)[m
 	} else {[m
 		err = json.Unmarshal([]byte(jsonCfg), &linterCfg)[m
 	}[m
[32m+[m
 	if err != nil {[m
 		return nil, err[m
 	}[m
[31m-	var cfg = &Config{[m
[32m+[m
[32m+[m	[32mcfg := &Config{[m
 		LinterCfg: linterCfg,[m
 		Repo:      repo,[m
 	}[m
[36m@@ -53,15 +56,18 @@[m [mfunc LoadCfg(repo, jsonCfg, yamlCfg string) (*Config, error) {[m
 	if cfg.LinterCfg.Workdir == "" {[m
 		cfg.LinterCfg.Workdir = "."[m
 	}[m
[32m+[m
 	if !path.IsAbs(cfg.LinterCfg.Workdir) {[m
 		cwd, err := os.Getwd()[m
 		if err != nil {[m
 			return nil, err[m
 		}[m
[32m+[m
 		cfg.LinterCfg.Workdir = path.Join(cwd, cfg.LinterCfg.Workdir)[m
 	}[m
 [m
 	cfg.Repo = strings.TrimSuffix(cfg.Repo, "/")[m
[32m+[m
 	cfg.RepoURL, err = url.Parse(cfg.Repo)[m
 	if err != nil {[m
 		return nil, err[m
[36m@@ -74,9 +80,11 @@[m [mfunc LoadCfg(repo, jsonCfg, yamlCfg string) (*Config, error) {[m
 	if cfg.LinterCfg.InstallCommand == "" {[m
 		return nil, fmt.Errorf("install_command is empty %+v", cfg)[m
 	}[m
[32m+[m
 	if cfg.LinterCfg.LinterCommand == "" {[m
 		return nil, fmt.Errorf("linter_command is empty %+v", cfg)[m
 	}[m
[32m+[m
 	return cfg, nil[m
 }[m
 [m
[36m@@ -87,5 +95,6 @@[m [mfunc (c *Config) GetTimeout(defaultDuration time.Duration) time.Duration {[m
 			return time.Duration(timeout) * time.Second[m
 		}[m
 	}[m
[32m+[m
 	return defaultDuration[m
 }[m
[1mdiff --git a/runner/run/execute.go b/runner/run/execute.go[m
[1mindex 047c581..9694445 100644[m
[1m--- a/runner/run/execute.go[m
[1m+++ b/runner/run/execute.go[m
[36m@@ -26,9 +26,11 @@[m [mfunc runCmd(cmd *exec.Cmd) error {[m
 	data, err := cmd.CombinedOutput()[m
 	log.Printf("run cmd %+v got len(output)=%d and err %+v\n", cmd, len(data), err)[m
 	fmt.Println(string(data))[m
[32m+[m
 	if err != nil {[m
 		return fmt.Errorf("run %s %+v failed %w", cmd.Path, cmd.Args, err)[m
 	}[m
[32m+[m
 	return nil[m
 }[m
 [m
[36m@@ -37,6 +39,7 @@[m [mfunc Prepare(ctx context.Context, cfg *Config) error {[m
 	name, args := utils.SplitCommand(cfg.LinterCfg.InstallCommand)[m
 	cmd := exec.CommandContext(ctx, name, args...)[m
 	cmd.Dir = cfg.LinterCfg.Workdir[m
[32m+[m
 	if err := runCmd(cmd); err != nil {[m
 		return err[m
 	}[m
[36m@@ -44,11 +47,14 @@[m [mfunc Prepare(ctx context.Context, cfg *Config) error {[m
 	// clone repo[m
 	cmd = exec.CommandContext(ctx, "rm", "-rf", cfg.RepoDir)[m
 	cmd.Dir = cfg.LinterCfg.Workdir[m
[32m+[m
 	if err := runCmd(cmd); err != nil {[m
 		return err[m
 	}[m
[32m+[m
 	cmd = exec.CommandContext(ctx, "git", "clone", cfg.Repo)[m
 	cmd.Dir = cfg.LinterCfg.Workdir[m
[32m+[m
 	if err := runCmd(cmd); err != nil {[m
 		return err[m
 	}[m
[36m@@ -63,6 +69,7 @@[m [mfunc Prepare(ctx context.Context, cfg *Config) error {[m
 	// run go mod download[m
 	cmd = exec.CommandContext(ctx, "go", "mod", "download")[m
 	cmd.Dir = cfg.RepoDir[m
[32m+[m
 	if err := runCmd(cmd); err != nil {[m
 		return err[m
 	}[m
[36m@@ -70,21 +77,26 @@[m [mfunc Prepare(ctx context.Context, cfg *Config) error {[m
 	// read default branch for repo[m
 	cmd = exec.CommandContext(ctx, "git", "branch", "--show-current")[m
 	cmd.Dir = cfg.RepoDir[m
[32m+[m
 	output, err := cmd.Output()[m
 	if err != nil {[m
 		return fmt.Errorf("git branch failed %w", err)[m
 	}[m
[32m+[m
 	cfg.RepoBranch = strings.TrimSpace(string(output))[m
 	cfg.RepoTarget = cfg.Repo + "/blob/" + cfg.RepoBranch[m
[32m+[m
 	return nil[m
 }[m
 [m
 func Build(ctx context.Context, cfg *Config) error {[m
 	cmd := exec.CommandContext(ctx, "go", "build", "./...")[m
 	cmd.Dir = cfg.RepoDir[m
[32m+[m
 	if err := runCmd(cmd); err != nil {[m
 		return err[m
 	}[m
[32m+[m
 	return nil[m
 }[m
 [m
[36m@@ -93,30 +105,38 @@[m [mfunc Run(ctx context.Context, cfg *Config) ([]string, error) {[m
 	args = append(args, "./...")[m
 	cmd := exec.CommandContext(ctx, name, args...)[m
 	cmd.Dir = cfg.RepoDir[m
[32m+[m
 	var stdout bytes.Buffer[m
[32m+[m
 	var stderr bytes.Buffer[m
[32m+[m
 	cmd.Stdout = &stdout[m
 	cmd.Stderr = &stderr[m
 	err := cmd.Run()[m
 	log.Printf("run cmd %+v got err %+v and exit code %+v \n", cmd, err, cmd.ProcessState.ExitCode())[m
 	fmt.Printf("stdout:\n%s\n", stdout.String())[m
 	fmt.Printf("stderr:\n%s\n", stderr.String())[m
[32m+[m
 	if err == nil {[m
 		log.Printf("err is nil and return")[m
[32m+[m
 		return nil, nil[m
 	}[m
 [m
 	if cmd.ProcessState.ExitCode() != DiagnosticExitCode {[m
 		log.Printf("ignore exit err %s\n", err.Error())[m
[32m+[m
 		return nil, nil[m
 	}[m
 [m
 	output := strings.TrimSpace(stderr.String())[m
 	if len(output) == 0 {[m
 		log.Printf("stderr output is empty, fallback to stdout")[m
[32m+[m
 		output = stdout.String()[m
 		if len(output) == 0 {[m
 			log.Printf("stdout output is still empty")[m
[32m+[m
 			return nil, nil[m
 		}[m
 	}[m
[36m@@ -126,15 +146,18 @@[m [mfunc Run(ctx context.Context, cfg *Config) ([]string, error) {[m
 	validOutputs := make([]string, 0, len(outputs))[m
 	includes := utils.GetStringArray(cfg.LinterCfg.Includes)[m
 	excludes := utils.GetStringArray(cfg.LinterCfg.Excludes)[m
[32m+[m
 	for _, line := range outputs {[m
 		line := strings.TrimSpace(line)[m
 		if len(line) == 0 {[m
 			continue[m
 		}[m
[32m+[m
 		if includeLine(includes, line) && !excludeLine(excludes, line) {[m
 			validOutputs = append(validOutputs, line)[m
 		}[m
 	}[m
[32m+[m
 	return validOutputs, nil[m
 }[m
 [m
[36m@@ -152,6 +175,7 @@[m [mfunc Parse(ctx context.Context, cfg *Config, outputs []string) []string {[m
 			outputs[i] = strings.ReplaceAll(line, ".go:", ".go#L")[m
 		}[m
 	}[m
[32m+[m
 	return outputs[m
 }[m
 [m
[36m@@ -159,14 +183,18 @@[m [mconst testFile = "_test.go"[m
 [m
 func FilterOutput(ctx context.Context, cfg *Config, outputs []string) []string {[m
 	result := make([]string, 0, len(outputs))[m
[31m-	for _, o := range outputs {[m
[32m+[m
[32m+[m	[32mfor _, line := range outputs {[m
 		// filter _test.go file[m
[31m-		if !cfg.LinterCfg.EnableTestFile && strings.Contains(o, testFile) {[m
[31m-			log.Println("ignore testfile output ", o)[m
[32m+[m		[32mif !cfg.LinterCfg.EnableTestfile && strings.Contains(line, testFile) {[m
[32m+[m			[32mlog.Println("ignore testfile output ", line)[m
[32m+[m
 			continue[m
 		}[m
[31m-		result = append(result, o)[m
[32m+[m
[32m+[m		[32mresult = append(result, line)[m
 	}[m
[32m+[m
 	return result[m
 }[m
 [m
[36m@@ -177,9 +205,11 @@[m [mfunc PrintOutput(ctx context.Context, cfg *Config, outputs []string) {[m
 	fmt.Println(divider)[m
 	fmt.Printf("runner config: %+v\n", cfg)[m
 	fmt.Println(divider)[m
[32m+[m
 	for _, line := range outputs {[m
 		fmt.Println(line)[m
 	}[m
[32m+[m
 	fmt.Println(divider)[m
 	fmt.Printf("Report issue: %s/issues\n", cfg.Repo)[m
 }[m
[36m@@ -188,11 +218,13 @@[m [mfunc includeLine(includes []string, line string) bool {[m
 	if len(includes) == 0 {[m
 		return true[m
 	}[m
[32m+[m
 	for _, v := range includes {[m
 		if strings.Contains(line, v) {[m
 			return true[m
 		}[m
 	}[m
[32m+[m
 	return false[m
 }[m
 [m
[36m@@ -200,11 +232,13 @@[m [mfunc excludeLine(excludes []string, line string) bool {[m
 	if len(excludes) == 0 {[m
 		return false[m
 	}[m
[32m+[m
 	for _, v := range excludes {[m
 		if strings.Contains(line, v) {[m
 			return true[m
 		}[m
 	}[m
[32m+[m
 	return false[m
 }[m
 [m
[36m@@ -219,7 +253,7 @@[m [mtype issueCommentData struct {[m
 }[m
 [m
 func buildIssueComment(cfg *Config, outputs []string) (string, error) {[m
[31m-	var data = &issueCommentData{[m
[32m+[m	[32mdata := &issueCommentData{[m
 		GithubActionLink: os.Getenv("GH_ACTION_LINK"),[m
 		Linter:           cfg.LinterCfg.LinterCommand,[m
 		RepositoryURL:    cfg.Repo,[m
[36m@@ -229,15 +263,18 @@[m [mfunc buildIssueComment(cfg *Config, outputs []string) (string, error) {[m
 		text := buildIssueCommentLine(cfg, line)[m
 		data.Lines = append(data.Lines, text)[m
 	}[m
[32m+[m
 	var tpl bytes.Buffer[m
[31m-	tmpl, err := template.New("issue_comment").Parse(issueCommentTemplate)[m
 [m
[32m+[m	[32mtmpl, err := template.New("issue_comment").Parse(issueCommentTemplate)[m
 	if err != nil {[m
 		return "", err[m
 	}[m
[32m+[m
 	if err := tmpl.Execute(&tpl, data); err != nil {[m
 		return "", err[m
 	}[m
[32m+[m
 	return tpl.String(), nil[m
 }[m
 [m
[36m@@ -246,9 +283,11 @@[m [mfunc buildIssueCommentLine(cfg *Config, line string) string {[m
 	if codePath == "" {[m
 		return line[m
 	}[m
[32m+[m
 	pathText := strings.TrimLeft(strings.ReplaceAll(codePath, cfg.RepoTarget, ""), "/:")[m
 	codePath = cleanCodePath(codePath)[m
 	pathText = cleanPathText(pathText)[m
[32m+[m
 	return fmt.Sprintf(`<a href="%s">%s</a> %s`, codePath, pathText, other)[m
 }[m
 [m
[36m@@ -257,6 +296,7 @@[m [mfunc cleanCodePath(codePath string) string {[m
 	if len(parts) <= 2 {[m
 		return codePath[m
 	}[m
[32m+[m
 	return strings.Join(parts[:2], ":")[m
 }[m
 [m
[36m@@ -265,6 +305,7 @@[m [mfunc cleanPathText(pathText string) string {[m
 	if len(parts) <= 1 {[m
 		return pathText[m
 	}[m
[32m+[m
 	return parts[0][m
 }[m
 [m
[36m@@ -277,6 +318,7 @@[m [mfunc buildIssueCommentLineSplit(cfg *Config, line string) (codePath string, othe[m
 	if strings.Contains(line, " ") {[m
 		return buildIssueCommentLineSplitStyle2(cfg, line)[m
 	}[m
[32m+[m
 	return "", line[m
 }[m
 [m
[36m@@ -287,15 +329,20 @@[m [mfunc buildIssueCommentLineSplitStyle1(cfg *Config, line string) (codePath string[m
 	if index < 0 {[m
 		return "", line[m
 	}[m
[32m+[m
 	other = line[:index][m
 	tail := line[index:][m
 	index = strings.Index(tail, " ")[m
[32m+[m
 	if index < 0 {[m
 		codePath = tail[m
[32m+[m
 		return strings.TrimSpace(codePath), strings.TrimSpace(other)[m
 	}[m
[32m+[m
 	codePath = tail[:index][m
 	other += tail[index:][m
[32m+[m
 	return strings.TrimSpace(codePath), strings.TrimSpace(other)[m
 }[m
 [m
[36m@@ -303,6 +350,7 @@[m [mfunc buildIssueCommentLineSplitStyle2(cfg *Config, line string) (codePath string[m
 	// style 2: badcodes/revive/revive_modify_value.go#L17:2: suspicious assignment to a by-value method receiver (false positive?)[m
 	parts := strings.Split(line, " ")[m
 	others := make([]string, 0)[m
[32m+[m
 	for _, part := range parts {[m
 		if len(part) == 0 {[m
 			continue[m
[36m@@ -322,6 +370,7 @@[m [mfunc buildIssueCommentLineSplitStyle2(cfg *Config, line string) (codePath string[m
 	if len(codePath) == 0 {[m
 		return "", line[m
 	}[m
[32m+[m
 	return codePath, strings.Join(others, " ")[m
 }[m
 [m
[36m@@ -330,10 +379,13 @@[m [mfunc CreateIssueComment(ctx context.Context, cfg *Config, outputs []string) erro[m
 	if err != nil {[m
 		return err[m
 	}[m
[32m+[m
 	cmd := exec.CommandContext(ctx, "gh", "issue", "comment",[m
 		cfg.LinterCfg.IssueID,[m
 		"--body", body)[m
 	cmd.Dir = "."[m
[32m+[m
 	log.Printf("comment on issue #%s\n", cfg.LinterCfg.IssueID)[m
[32m+[m
 	return runCmd(cmd)[m
 }[m
[1mdiff --git a/runner/run/execute_test.go b/runner/run/execute_test.go[m
[1mindex 9caebf7..f9ac3f1 100644[m
[1m--- a/runner/run/execute_test.go[m
[1m+++ b/runner/run/execute_test.go[m
[36m@@ -4,31 +4,33 @@[m [mimport ([m
 	"context"[m
 	"fmt"[m
 	"net/url"[m
[31m-	"os"[m
 	"strings"[m
 	"testing"[m
 )[m
 [m
 func TestBuildIssueComment(t *testing.T) {[m
[31m-	var outputs = []string{[m
[32m+[m	[32moutputs := []string{[m
 		"append to slice `x` with non-zero initialized length at https://github.com/alingse/makezero/blob/master/examples/example.go#L7:6",[m
 	}[m
[31m-	var cfg = &Config{[m
[32m+[m
[32m+[m	[32mcfg := &Config{[m
 		RepoTarget: "https://github.com/alingse/makezero/blob/master",[m
 		Repo:       "https://github.com/alingse/makezero",[m
 		LinterCfg: LinterCfg{[m
 			LinterCommand: "makezero",[m
 		},[m
 	}[m
[32m+[m
 	body, err := buildIssueComment(cfg, outputs)[m
 	if err != nil {[m
 		t.Errorf("Failed with error: %v", err)[m
 	}[m
[32m+[m
 	t.Logf("build issue got %s \n", body)[m
 }[m
 [m
 func TestBuildIssueCommentLine(t *testing.T) {[m
[31m-	var cases = [][3]string{[m
[32m+[m	[32mcases := [][3]string{[m
 		{[m
 			"append to slice `x` with non-zero initialized length at https://github.com/alingse/makezero/blob/master/examples/example.go#L7:6",[m
 			"https://github.com/alingse/makezero/blob/master",[m
[36m@@ -50,6 +52,7 @@[m [mfunc TestBuildIssueCommentLine(t *testing.T) {[m
 		t.Run(fmt.Sprintf("case %d", i), func(t *testing.T) {[m
 			line := c[0][m
 			cfg := &Config{RepoTarget: c[1]}[m
[32m+[m
 			text := buildIssueCommentLine(cfg, line)[m
 			if text != c[2] {[m
 				t.Errorf("expect %s but is %s", c[2], text)[m
[36m@@ -59,7 +62,7 @@[m [mfunc TestBuildIssueCommentLine(t *testing.T) {[m
 }[m
 [m
 func TestBuildIssueCommentLineSplit(t *testing.T) {[m
[31m-	var cases = [][4]string{[m
[32m+[m	[32mcases := [][4]string{[m
 		{[m
 			"append to slice `x` with non-zero initialized length at https://github.com/alingse/makezero/blob/master/examples/example.go#L7:6",[m
 			"https://github.com/alingse/makezero/blob/master",[m
[36m@@ -73,14 +76,17 @@[m [mfunc TestBuildIssueCommentLineSplit(t *testing.T) {[m
 			"error-nil: use require.NoError",[m
 		},[m
 	}[m
[32m+[m
 	for i, c := range cases {[m
 		t.Run(fmt.Sprintf("case %d", i), func(t *testing.T) {[m
 			line := c[0][m
 			cfg := &Config{RepoTarget: c[1]}[m
[32m+[m
 			code, other := buildIssueCommentLineSplit(cfg, line)[m
 			if code != c[2] {[m
 				t.Errorf("expect %s but is %s", c[2], code)[m
 			}[m
[32m+[m
 			if other != c[3] {[m
 				t.Errorf("expect %s but is %s", c[3], other)[m
 			}[m
[36m@@ -89,9 +95,11 @@[m [mfunc TestBuildIssueCommentLineSplit(t *testing.T) {[m
 }[m
 [m
 func TestOutput(t *testing.T) {[m
[31m-	var ctx = context.Background()[m
[31m-	var output = `badcodes/revive/revive_modify_value.go:17:2: suspicious assignment to a by-value method receiver (false positive?)[m
[32m+[m	[32mctx := context.Background()[m
[32m+[m
[32m+[m	[32moutput := `badcodes/revive/revive_modify_value.go:17:2: suspicious assignment to a by-value method receiver (false positive?)[m
 badcodes/revive/revive_modify_value.go:22:2: suspicious assignment to a by-value method receiver (false positive?)`[m
[32m+[m
 	outputs := strings.Split(output, "\n")[m
 [m
 	repo := "https://github.com/alingse/go-linter-runner-example"[m
[36m@@ -102,13 +110,16 @@[m [mbadcodes/revive/revive_modify_value.go:22:2: suspicious assignment to a by-value[m
 		RepoURL:    repoURL,[m
 		Repo:       repo,[m
 	}[m
[31m-	os.Setenv("GH_ACTION_LINK", "https://github.com/xxx")[m
[32m+[m
[32m+[m	[32mt.Setenv("GH_ACTION_LINK", "https://github.com/xxx")[m
[32m+[m
 	outputs = Parse(ctx, cfg, outputs)[m
 [m
 	body, err := buildIssueComment(cfg, outputs)[m
 	if err != nil {[m
 		t.Errorf("err should be nil but got %+v", err)[m
 	}[m
[32m+[m
 	expected := `Run ` + "``" + ` on Repo: https://github.com/alingse/go-linter-runner-example[m
 [m
 Got total 2 lines output in action: https://github.com/xxx[m
[1mdiff --git a/runner/submit.go b/runner/submit.go[m
[1mindex 693d853..419ddde 100644[m
[1m--- a/runner/submit.go[m
[1m+++ b/runner/submit.go[m
[36m@@ -16,17 +16,22 @@[m [mfunc Submit(sourceFile string, repoCount int64, workflow string) {[m
 	repos, err := submit.ReadSubmitRepos(sourceFile, repoCount)[m
 	if err != nil {[m
 		log.Fatalf("read submit source file failed %s %+v", sourceFile, err)[m
[32m+[m
 		return[m
 	}[m
[32m+[m
 	if len(repos) == 0 {[m
 		log.Fatalf("read submit source file got empty %s", sourceFile)[m
[32m+[m
 		return[m
 	}[m
 	// Submit[m
 	ctx := context.Background()[m
[32m+[m
 	err = submit.SumitActions(ctx, workflow, repos)[m
 	if err != nil {[m
 		log.Fatalf("submit repos failed with %+v", err)[m
[32m+[m
 		return[m
 	}[m
 }[m
[1mdiff --git a/runner/submit/execute.go b/runner/submit/execute.go[m
[1mindex e0001ac..dadb799 100644[m
[1m--- a/runner/submit/execute.go[m
[1m+++ b/runner/submit/execute.go[m
[36m@@ -20,6 +20,7 @@[m [mfunc getSourceReader(source string) (io.ReadCloser, error) {[m
 	if strings.HasPrefix(source, "https://") || strings.HasPrefix(source, "http://") {[m
 		return getHTTPReader(source)[m
 	}[m
[32m+[m
 	if utils.IsFileExists(source) {[m
 		return getFileReader(source)[m
 	}[m
[36m@@ -33,6 +34,7 @@[m [mfunc getSourceReader(source string) (io.ReadCloser, error) {[m
 	}[m
 [m
 	url := "https://raw.githubusercontent.com/alingse/go-linter-runner/main/source/" + source[m
[32m+[m
 	return getHTTPReader(url)[m
 }[m
 [m
[36m@@ -41,6 +43,7 @@[m [mfunc getFileReader(path string) (io.ReadCloser, error) {[m
 	if err != nil {[m
 		return nil, err[m
 	}[m
[32m+[m
 	return f, nil[m
 }[m
 [m
[36m@@ -49,9 +52,11 @@[m [mfunc getHTTPReader(url string) (io.ReadCloser, error) {[m
 	if err != nil {[m
 		return nil, err[m
 	}[m
[32m+[m
 	if resp.StatusCode != http.StatusOK {[m
 		return nil, fmt.Errorf("Get url %s failed with status %d", url, resp.StatusCode)[m
 	}[m
[32m+[m
 	return resp.Body, nil[m
 }[m
 [m
[36m@@ -64,34 +69,42 @@[m [mfunc ReadSubmitRepos(source string, count int64) ([]string, error) {[m
 [m
 	repos := make([]string, 0, int(count))[m
 	scanner := bufio.NewScanner(reader)[m
[32m+[m
 	for scanner.Scan() {[m
 		if len(repos) >= int(count) {[m
 			return repos, nil[m
 		}[m
[32m+[m
 		line := scanner.Text()[m
[32m+[m
 		repo, err := url.Parse(line)[m
 		if err != nil {[m
 			return nil, err[m
 		}[m
[32m+[m
 		repos = append(repos, repo.String())[m
 	}[m
[32m+[m
 	return repos, nil[m
 }[m
 [m
 func SumitActions(ctx context.Context, workflow string, repos []string) error {[m
 	for i, repo := range repos {[m
 		log.Printf("submit repo %d : %s \n", i, repo)[m
[32m+[m
 		err := submitRepo(ctx, workflow, repo)[m
 		if err != nil {[m
 			return err[m
 		}[m
 	}[m
[32m+[m
 	return nil[m
 }[m
 [m
 func submitRepo(ctx context.Context, workflow string, repo string) error {[m
 	cmd := exec.CommandContext(ctx, "gh", "workflow", "run", workflow,[m
[31m-		"-F", fmt.Sprintf("repo_url=%s", repo))[m
[32m+[m		[32m"-F", "repo_url="+repo)[m
 	cmd.Dir = "."[m
[32m+[m
 	return utils.RunCmd(cmd)[m
 }[m
[1mdiff --git a/runner/utils/util.go b/runner/utils/util.go[m
[1mindex c972282..a232752 100644[m
[1m--- a/runner/utils/util.go[m
[1m+++ b/runner/utils/util.go[m
[36m@@ -13,9 +13,11 @@[m [mfunc IsFileExists(filename string) bool {[m
 	if os.IsNotExist(err) {[m
 		return false[m
 	}[m
[32m+[m
 	if err != nil {[m
 		return false[m
 	}[m
[32m+[m
 	return true[m
 }[m
 [m
[36m@@ -25,6 +27,7 @@[m [mfunc GetStringArray(s any) (ss []string) {[m
 		if value == "" || value == "[]" {[m
 			return[m
 		}[m
[32m+[m
 		_ = json.Unmarshal([]byte(value), &ss)[m
 	case []string:[m
 		return[m
[36m@@ -32,9 +35,11 @@[m [mfunc GetStringArray(s any) (ss []string) {[m
 		if len(value) == 0 {[m
 			return[m
 		}[m
[32m+[m
 		data, _ := json.Marshal(value)[m
 		_ = json.Unmarshal(data, &ss)[m
 	}[m
[32m+[m
 	return[m
 }[m
 [m
[36m@@ -45,6 +50,7 @@[m [mfunc CastToBool(v any) bool {[m
 	case bool:[m
 		return v[m
 	}[m
[32m+[m
 	return false[m
 }[m
 [m
[36m@@ -53,14 +59,17 @@[m [mfunc SplitCommand(command string) (name string, args []string) {[m
 	if len(fields) == 1 {[m
 		return fields[0], nil[m
 	}[m
[32m+[m
 	return fields[0], fields[1:][m
 }[m
 [m
 func RunCmd(cmd *exec.Cmd) error {[m
 	data, err := cmd.CombinedOutput()[m
 	fmt.Println(string(data))[m
[32m+[m
 	if err != nil {[m
 		return fmt.Errorf("run %s %+v failed %w", cmd.Path, cmd.Args, err)[m
 	}[m
[32m+[m
 	return nil[m
 }[m
